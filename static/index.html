<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>16-Bit Portrait Generator</title>
<style>
  :root {
    --bg: #1a1a2e;
    --bg2: #16213e;
    --bg3: #0f3460;
    --accent: #e94560;
    --text: #eee;
    --text-dim: #8892b0;
    --border: #2a2a4a;
    --success: #4ade80;
    --error: #f87171;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  /* Embed mode: constrain UI for iframe integration */
  body.embed-mode header { display: none; }
  body.embed-mode .status-bar { display: none; }
  body.embed-mode .sidebar .section.settings-section .control.embed-hide { display: none; }
  body.embed-mode .sidebar .section.download-section { display: none; }
  body.embed-mode .sidebar .section.save-section { display: block; }
  .sidebar .section.save-section { display: none; }

  body {
    font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
  }

  header {
    background: var(--bg2);
    border-bottom: 2px solid var(--accent);
    padding: 16px 24px;
    display: flex;
    align-items: center;
    gap: 12px;
  }

  header h1 {
    font-size: 18px;
    font-weight: 600;
    letter-spacing: 1px;
  }

  header .badge {
    background: var(--accent);
    color: white;
    font-size: 10px;
    padding: 2px 8px;
    border-radius: 4px;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .container {
    display: grid;
    grid-template-columns: 280px 1fr auto auto;
    gap: 0;
    min-height: calc(100vh - 58px);
  }

  .sidebar {
    background: var(--bg2);
    padding: 20px;
    border-right: 1px solid var(--border);
    overflow-y: auto;
  }

  .canvas-area {
    padding: 20px;
    display: flex;
    flex-direction: column;
    min-height: 0;
    overflow: hidden;
  }

  /* Shared collapsible rail styles */
  .rail-panel {
    background: var(--bg2);
    border-left: 1px solid var(--border);
    overflow-y: auto;
    overflow-x: hidden;
    display: flex;
    flex-direction: column;
    width: 260px;
    transition: width 0.15s ease;
  }

  .rail-panel .rail-header {
    display: flex;
    align-items: center;
    padding: 8px 16px;
    cursor: pointer;
    user-select: none;
    white-space: nowrap;
  }

  .rail-panel .rail-title {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--text-dim);
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .rail-panel .rail-chevron {
    transition: transform 0.2s;
    color: var(--text-dim);
    flex-shrink: 0;
  }

  .rail-panel .rail-body {
    padding: 0 16px 16px;
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  /* Collapsed state: narrow vertical strip with rotated label */
  .rail-panel.collapsed {
    width: 36px;
    overflow: hidden;
  }

  .rail-panel.collapsed .rail-header {
    padding: 12px 0;
    justify-content: center;
  }

  .rail-panel.collapsed .rail-title {
    writing-mode: vertical-rl;
    text-orientation: mixed;
    gap: 6px;
  }

  .rail-panel.collapsed .rail-chevron {
    transform: rotate(-90deg);
  }

  .rail-panel.collapsed .rail-body {
    display: none;
  }

  .section {
    margin-bottom: 20px;
  }

  .section-title {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--text-dim);
    margin-bottom: 12px;
    padding-bottom: 6px;
    border-bottom: 1px solid var(--border);
  }

  .panel-title {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--text-dim);
    margin-bottom: 8px;
    padding-bottom: 6px;
    border-bottom: 1px solid var(--border);
  }

  .upload-area {
    border: 2px dashed var(--border);
    border-radius: 8px;
    padding: 24px;
    text-align: center;
    cursor: pointer;
    transition: border-color 0.2s, background 0.2s;
  }

  .upload-area:hover, .upload-area.dragover {
    border-color: var(--accent);
    background: rgba(233, 69, 96, 0.05);
  }

  .upload-area p { font-size: 13px; color: var(--text-dim); margin-top: 8px; }

  .btn-row { display: flex; gap: 8px; margin-top: 12px; }

  .btn {
    flex: 1;
    padding: 10px 16px;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--bg3);
    color: var(--text);
    font-family: inherit;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s;
    text-align: center;
  }

  .btn:hover { border-color: var(--accent); background: rgba(233, 69, 96, 0.15); }
  .btn:disabled { opacity: 0.4; cursor: not-allowed; }

  .btn.primary {
    background: var(--accent);
    border-color: var(--accent);
    color: white;
    font-weight: 600;
  }

  .btn.primary:hover { background: #d63452; }

  .source-preview {
    margin-top: 12px;
    border-radius: 6px;
    overflow: hidden;
    background: var(--bg);
    aspect-ratio: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
  }

  .source-preview img {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
  }

  .source-preview .placeholder {
    color: var(--text-dim);
    font-size: 12px;
  }

  .source-preview .crop-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }

  .crop-controls {
    margin-top: 8px;
    display: none;
    flex-direction: column;
    gap: 6px;
  }

  .crop-controls.visible {
    display: flex;
  }

  .crop-controls .control label {
    font-size: 11px;
  }

  .crop-controls .control .value {
    font-size: 11px;
    color: var(--text);
    min-width: 36px;
    text-align: right;
  }

  .crop-controls .btn-row {
    margin-top: 2px;
  }

  .control {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 10px;
  }

  .control label {
    font-size: 12px;
    color: var(--text-dim);
  }

  .control select, .control input[type="range"], .control input[type="number"] {
    background: var(--bg);
    border: 1px solid var(--border);
    color: var(--text);
    border-radius: 4px;
    padding: 4px 8px;
    font-family: inherit;
    font-size: 12px;
  }

  .control select { width: 120px; }
  .control input[type="range"] { width: 100px; }
  .control input[type="number"] { width: 60px; text-align: center; }

  .control .value {
    font-size: 11px;
    color: var(--accent);
    min-width: 32px;
    text-align: right;
  }

  .control input[type="checkbox"] {
    accent-color: var(--accent);
    width: 16px;
    height: 16px;
  }

  /* Canvas display */
  .result-card {
    background: var(--bg2);
    border: 1px solid var(--border);
    border-radius: 8px;
    width: 100%;
    display: flex;
    flex-direction: column;
    flex: 1;
    min-height: 0;
    overflow: hidden;
  }

  .portrait-toolbar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 12px;
    border-bottom: 1px solid var(--border);
    gap: 12px;
    flex-shrink: 0;
  }

  .toolbar-left {
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 11px;
    color: var(--text-dim);
    flex-shrink: 0;
  }

  .toolbar-left .dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--text-dim);
    flex-shrink: 0;
  }

  .toolbar-left .dot.active { background: var(--success); }
  .toolbar-left .dot.processing { background: var(--accent); animation: pulse 1s infinite; }

  .toolbar-title {
    font-size: 13px;
    font-weight: 600;
    color: var(--text);
  }

  .meta-inline .label { color: var(--text-dim); }
  .meta-inline .val { color: var(--text); margin-left: 4px; }

  .toolbar-right {
    display: flex;
    align-items: center;
    gap: 6px;
    flex-shrink: 0;
  }

  .zoom-btn {
    width: 26px;
    height: 26px;
    border: 1px solid var(--border);
    border-radius: 4px;
    background: var(--bg);
    color: var(--text);
    font-family: inherit;
    font-size: 14px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s;
    padding: 0;
  }

  .zoom-btn:hover { border-color: var(--accent); background: rgba(233, 69, 96, 0.15); }

  .zoom-btn.text {
    width: auto;
    padding: 0 8px;
    font-size: 11px;
  }

  .zoom-slider {
    width: 80px;
    accent-color: var(--accent);
    height: 4px;
  }

  .zoom-pct {
    font-size: 11px;
    color: var(--text);
    min-width: 36px;
    text-align: center;
  }

  .zoom-invert-label {
    font-size: 10px;
    color: var(--text-dim);
    display: flex;
    align-items: center;
    gap: 3px;
    cursor: pointer;
    margin-left: 4px;
  }

  .zoom-invert-label input {
    accent-color: var(--accent);
    width: 12px;
    height: 12px;
  }

  @keyframes pulse { 50% { opacity: 0.3; } }

  .canvas-wrap {
    background: var(--bg);
    overflow: auto;
    position: relative;
    flex: 1;
    min-height: 0;
  }

  .canvas-wrap canvas {
    image-rendering: pixelated;
    image-rendering: -moz-crisp-edges;
    image-rendering: crisp-edges;
    display: block;
  }

  .canvas-wrap canvas.brush-active {
    cursor: none;
  }

  .canvas-wrap .spinner {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: none;
    z-index: 20;
  }

  .canvas-wrap .spinner.show {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
  }

  .spinner-ring {
    width: 32px;
    height: 32px;
    border: 3px solid var(--border);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  .meta-sep {
    color: var(--border);
    margin: 0 2px;
  }

  /* Brush cursor overlay */
  .brush-cursor {
    position: absolute;
    pointer-events: none;
    border: 2px solid var(--accent);
    box-sizing: border-box;
    display: none;
    z-index: 10;
    mix-blend-mode: difference;
  }

  .brush-cursor.transparent-brush {
    border-style: dashed;
    border-color: #fff;
  }

  /* Retouch panel: palette */
  .palette-swatches {
    display: flex;
    flex-wrap: wrap;
    gap: 3px;
  }

  .palette-swatches .swatch {
    width: 20px;
    height: 20px;
    border-radius: 3px;
    border: 1px solid rgba(255,255,255,0.1);
    cursor: pointer;
    transition: transform 0.1s;
  }

  .palette-swatches .swatch:hover {
    transform: scale(1.2);
    border-color: rgba(255,255,255,0.4);
  }

  .palette-swatches .swatch.active {
    outline: 2px solid var(--accent);
    outline-offset: 1px;
    transform: scale(1.2);
  }

  .palette-swatches .swatch.transparent {
    background: repeating-conic-gradient(#808080 0% 25%, #c0c0c0 0% 50%) 50% / 8px 8px !important;
  }

  /* Brush size buttons */
  .size-btns {
    display: flex;
    gap: 4px;
  }

  .size-btn {
    width: 28px;
    height: 28px;
    border: 1px solid var(--border);
    border-radius: 4px;
    background: var(--bg);
    color: var(--text);
    font-family: inherit;
    font-size: 12px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .size-btn.active {
    border-color: var(--accent);
    background: var(--accent);
    color: #000;
  }

  /* Active brush preview */
  .active-brush-preview {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px;
    background: var(--bg);
    border-radius: 6px;
    font-size: 11px;
    color: var(--text-dim);
    min-height: 36px;
  }

  .active-brush-preview .preview-swatch {
    width: 20px;
    height: 20px;
    border-radius: 3px;
    border: 1px solid rgba(255,255,255,0.2);
    flex-shrink: 0;
  }

  .active-brush-preview .preview-swatch.transparent {
    background: repeating-conic-gradient(#808080 0% 25%, #c0c0c0 0% 50%) 50% / 8px 8px !important;
  }

  /* History buttons (undo/redo) */
  .history-row {
    display: flex;
    gap: 6px;
  }

  .history-btn {
    flex: 1;
    padding: 8px 12px;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--bg);
    color: var(--text);
    font-family: inherit;
    font-size: 12px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    transition: all 0.2s;
  }

  .history-btn:hover:not(:disabled) { border-color: var(--accent); background: rgba(233, 69, 96, 0.15); }
  .history-btn:disabled { opacity: 0.3; cursor: not-allowed; }

  .history-count {
    font-size: 10px;
    background: var(--bg3);
    padding: 1px 5px;
    border-radius: 3px;
    color: var(--text-dim);
  }

  /* Eyedropper tool */
  .tool-btn {
    padding: 8px 12px;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--bg);
    color: var(--text);
    font-family: inherit;
    font-size: 12px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: all 0.2s;
    width: 100%;
  }

  .tool-btn:hover { border-color: var(--accent); background: rgba(233, 69, 96, 0.15); }

  .tool-btn.active {
    border-color: var(--accent);
    background: var(--accent);
    color: #000;
  }

  .tool-btn svg { flex-shrink: 0; }

  .canvas-wrap canvas.eyedropper-active {
    cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M2 22l1-1h3l9-9'/%3E%3Cpath d='M3 21l9-9'/%3E%3Ccircle cx='17' cy='7' r='3'/%3E%3Cpath d='M20 4l1-1'/%3E%3C/svg%3E") 2 22, crosshair;
  }

  /* Shortcuts reference */
  .shortcuts {
    font-size: 10px;
    color: var(--text-dim);
    line-height: 1.8;
  }

  .shortcuts kbd {
    display: inline-block;
    padding: 1px 5px;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 3px;
    font-family: inherit;
    font-size: 10px;
    color: var(--text);
    min-width: 18px;
    text-align: center;
  }

  .download-row {
    display: flex;
    gap: 8px;
    margin-top: 16px;
  }

  .status-bar {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: var(--bg2);
    border-top: 1px solid var(--border);
    padding: 6px 20px;
    font-size: 11px;
    color: var(--text-dim);
    display: flex;
    gap: 20px;
  }

  .status-bar .indicator {
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .status-bar .dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
  }

  /* ---- File Organizer Panel (right rail) ---- */
  .file-organizer .fo-body {
    gap: 12px;
  }

  .fo-field {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .fo-field label {
    font-size: 11px;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .fo-field .fo-input-row {
    display: flex;
    gap: 6px;
  }

  .fo-field input[type="text"] {
    flex: 1;
    background: var(--bg);
    border: 1px solid var(--border);
    color: var(--text);
    border-radius: 4px;
    padding: 6px 10px;
    font-family: inherit;
    font-size: 12px;
    min-width: 0;
  }

  .fo-field input[type="text"]::placeholder {
    color: var(--text-dim);
    opacity: 0.6;
  }

  .fo-settings {
    display: flex;
    flex-wrap: wrap;
    gap: 6px 14px;
  }

  .fo-settings label {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 11px;
    color: var(--text-dim);
    cursor: pointer;
    white-space: nowrap;
  }

  .fo-settings label input[type="checkbox"] {
    accent-color: var(--accent);
    width: 14px;
    height: 14px;
  }

  .fo-retouched-wrap {
    display: flex;
    align-items: center;
    gap: 5px;
  }

  .fo-dirty-dot {
    width: 7px;
    height: 7px;
    border-radius: 50%;
    background: var(--text-dim);
    transition: background 0.2s;
  }

  .fo-dirty-dot.dirty {
    background: var(--accent);
    animation: pulse 1.5s infinite;
  }

  .fo-preview {
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding: 8px 12px;
    background: var(--bg);
    border-radius: 6px;
    font-size: 12px;
    min-height: 36px;
  }

  .fo-preview .fo-filename {
    font-family: inherit;
    color: var(--text);
    word-break: break-all;
    flex: 1;
  }

  .fo-preview .fo-filename .fo-dim {
    color: var(--text-dim);
  }

  .fo-preview .btn-save {
    padding: 8px 16px;
    font-weight: 600;
    width: 100%;
  }

  @media (max-width: 1000px) {
    .container { grid-template-columns: 1fr; }
    .rail-panel { width: auto; border-left: none; border-top: 1px solid var(--border); }
    .rail-panel.collapsed { width: auto; }
    .rail-panel.collapsed .rail-header { height: auto; }
    .rail-panel.collapsed .rail-title { writing-mode: horizontal-tb; }
  }
</style>
</head>
<body>

<header>
  <h1>16-Bit Portrait Generator</h1>
  <span class="badge">Algorithmic</span>
</header>

<div class="container">
  <div class="sidebar">
    <!-- Upload -->
    <div class="section">
      <div class="section-title">Source Image</div>
      <div class="upload-area" id="dropZone">
        <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
          <polyline points="17 8 12 3 7 8"/>
          <line x1="12" y1="3" x2="12" y2="15"/>
        </svg>
        <p>Drop a photo or click to upload</p>
      </div>
      <div class="btn-row">
        <button class="btn" id="btnUpload">Upload Photo</button>
        <button class="btn" id="btnCamera">Use Camera</button>
      </div>
      <input type="file" id="fileInput" accept="image/jpeg,image/png,image/webp" hidden>
      <div class="source-preview" id="sourcePreview">
        <span class="placeholder">No image loaded</span>
      </div>
      <div class="crop-controls" id="cropControls">
        <div class="control">
          <label>Rotation</label>
          <input type="range" id="cropRotation" min="-45" max="45" step="1" value="0">
          <span class="value" id="cropRotationVal">0&deg;</span>
        </div>
        <div class="control">
          <label>Crop Size</label>
          <input type="range" id="cropSize" min="50" max="200" step="5" value="100">
          <span class="value" id="cropSizeVal">100%</span>
        </div>
        <div class="btn-row">
          <button class="btn" id="btnCropReset" style="font-size:11px; padding:4px 10px;">Reset Crop</button>
        </div>
      </div>
    </div>

    <!-- Settings -->
    <div class="section settings-section">
      <div class="section-title">Settings</div>

      <div class="control embed-hide">
        <label>Output Size</label>
        <select id="outputSize">
          <option value="32">32 &times; 32</option>
          <option value="48">48 &times; 48</option>
          <option value="64" selected>64 &times; 64</option>
          <option value="96">96 &times; 96</option>
          <option value="128">128 &times; 128</option>
        </select>
      </div>

      <div class="control embed-hide">
        <label>Colors</label>
        <select id="paletteColors">
          <option value="8">8</option>
          <option value="16" selected>16</option>
          <option value="24">24</option>
          <option value="32">32</option>
          <option value="64">64</option>
        </select>
      </div>

      <div class="control embed-hide">
        <label>Palette</label>
        <select id="paletteName">
          <option value="">Auto (derived)</option>
        </select>
      </div>

      <div class="control">
        <label>Dither</label>
        <select id="dither">
          <option value="none" selected>None</option>
          <option value="bayer2x2">Bayer 2&times;2</option>
          <option value="bayer4x4">Bayer 4&times;4</option>
          <option value="floyd-steinberg">Floyd-Steinberg</option>
        </select>
      </div>

      <div class="control embed-hide">
        <label>SNES Snap</label>
        <input type="checkbox" id="snesSnap" checked>
      </div>

      <div class="control">
        <label>Remove BG</label>
        <input type="checkbox" id="removeBg">
      </div>

      <div class="control" id="bgThresholdControl" style="display:none">
        <label>BG Threshold</label>
        <input type="range" id="bgThreshold" min="0" max="1" step="0.05" value="0.5">
        <span class="value" id="bgThresholdVal">0.5</span>
      </div>

      <div class="control embed-hide">
        <label>Export Scale</label>
        <select id="scale">
          <option value="4">4&times;</option>
          <option value="8" selected>8&times;</option>
          <option value="12">12&times;</option>
          <option value="16">16&times;</option>
        </select>
      </div>

    </div>

    <!-- Download (hidden in embed mode) -->
    <div class="section download-section">
      <div class="download-row">
        <button class="btn primary" id="btnDownload" style="flex:1" disabled>Download PNG</button>
        <button class="btn" id="btnDownloadAll" style="flex:1" disabled>All Sizes</button>
      </div>
    </div>

    <!-- Save Portrait (shown only in embed mode) -->
    <div class="section save-section">
      <button class="btn primary" id="btnSavePortrait" style="width:100%" disabled>Save Portrait</button>
      <button class="btn" id="btnCancelEmbed" style="width:100%; margin-top:8px">Cancel</button>
    </div>
  </div>

  <!-- Canvas -->
  <div class="canvas-area">
    <div class="result-card">
      <div class="portrait-toolbar">
        <div class="toolbar-left">
          <span class="dot" id="browserDot"></span>
          <span class="toolbar-title">Portrait</span>
          <span class="meta-sep">|</span>
          <span class="meta-inline"><span class="label">Time:</span><span class="val" id="browserTime">&mdash;</span></span>
          <span class="meta-inline"><span class="label">Colors:</span><span class="val" id="browserColorCount">&mdash;</span></span>
          <span class="meta-inline"><span class="label">Export:</span><span class="val" id="exportSize">&mdash;</span></span>
        </div>
        <div class="toolbar-right">
          <button class="zoom-btn" id="zoomOut" title="Zoom out">&minus;</button>
          <input type="range" class="zoom-slider" id="zoomSlider" min="25" max="800" value="100">
          <button class="zoom-btn" id="zoomIn" title="Zoom in">+</button>
          <span class="zoom-pct" id="zoomPct">100%</span>
          <button class="zoom-btn text" id="zoomReset" title="Reset to 100%">Reset</button>
          <label class="zoom-invert-label" title="Invert scroll wheel zoom direction">
            <input type="checkbox" id="zoomInvert"> Invert
          </label>
        </div>
      </div>
      <div class="canvas-wrap" id="canvasWrap">
        <canvas id="browserCanvas" width="512" height="512"></canvas>
        <div class="brush-cursor" id="brushCursor"></div>
        <div class="spinner" id="browserSpinner">
          <div class="spinner-ring"></div>
          <span style="font-size:11px;color:var(--text-dim)">Processing...</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Retouch Panel -->
  <div class="retouch-panel rail-panel" id="retouchPanel">
    <div class="rail-header" id="rpToggle">
      <span class="rail-title">
        <svg class="rail-chevron" width="12" height="12" viewBox="0 0 24 24" fill="none"
             stroke="currentColor" stroke-width="2">
          <polyline points="6 9 12 15 18 9"/>
        </svg>
        Retouch
      </span>
    </div>
    <div class="rp-body rail-body">
    <div>
      <div class="panel-title">Palette</div>
      <div class="palette-swatches" id="browserSwatches">
        <span style="font-size:11px;color:var(--text-dim)">Generate a portrait first</span>
      </div>
    </div>

    <div>
      <div class="panel-title">Active Brush</div>
      <div class="active-brush-preview" id="activeBrushPreview">
        <span>No brush selected &mdash; click a swatch</span>
      </div>
    </div>

    <div>
      <div class="panel-title">Brush Size</div>
      <div class="size-btns" id="sizeBtns">
        <button class="size-btn active" data-size="1">1</button>
        <button class="size-btn" data-size="2">2</button>
        <button class="size-btn" data-size="3">3</button>
        <button class="size-btn" data-size="4">4</button>
      </div>
    </div>

    <div>
      <div class="panel-title">Tools</div>
      <button class="tool-btn" id="btnEyedropper">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M2 22l1-1h3l9-9"/>
          <path d="M3 21l9-9"/>
          <circle cx="17" cy="7" r="3"/>
          <path d="M20 4l1-1"/>
        </svg>
        Eyedropper
      </button>
    </div>

    <div>
      <div class="panel-title">History</div>
      <div class="history-row">
        <button class="history-btn" id="btnUndo" disabled>
          Undo <span class="history-count" id="undoCount">0</span>
        </button>
        <button class="history-btn" id="btnRedo" disabled>
          Redo <span class="history-count" id="redoCount">0</span>
        </button>
      </div>
    </div>

    <div>
      <div class="panel-title">Shortcuts</div>
      <div class="shortcuts">
        <kbd>1</kbd>&ndash;<kbd>4</kbd> Brush size<br>
        <kbd>Esc</kbd> Deselect brush<br>
        <kbd>Ctrl</kbd>+<kbd>Z</kbd> Undo<br>
        <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Z</kbd> Redo<br>
        <kbd>Ctrl</kbd>+click Eyedropper<br>
        <b>Left click</b> &mdash; Paint<br>
        <b>Click + drag</b> &mdash; Stroke<br>
        <b>Right click</b> &mdash; Flood fill
      </div>
    </div>
    </div><!-- /.rp-body -->
  </div>

  <!-- File Organizer Panel -->
  <div class="file-organizer rail-panel collapsed" id="fileOrganizer">
    <div class="rail-header" id="foToggle">
      <span class="rail-title">
        <svg class="rail-chevron" width="12" height="12" viewBox="0 0 24 24" fill="none"
             stroke="currentColor" stroke-width="2">
          <polyline points="6 9 12 15 18 9"/>
        </svg>
        File Organizer
      </span>
    </div>
    <div class="fo-body rail-body">
      <div class="fo-field">
        <label>Save Directory</label>
        <div class="fo-input-row">
          <input type="text" id="foDirectory" placeholder="No directory selected" readonly>
          <button class="btn" id="foBrowse">Browse</button>
        </div>
      </div>

      <div class="fo-field">
        <label>Root File Name</label>
        <input type="text" id="foRootName" placeholder="photo_16bit">
      </div>

      <div class="fo-field">
        <label>Include in Filename</label>
        <div class="fo-settings">
          <label><input type="checkbox" id="foIncSize" checked> Size</label>
          <label><input type="checkbox" id="foIncColors" checked> Colors</label>
          <label><input type="checkbox" id="foIncPalette"> Palette</label>
          <label><input type="checkbox" id="foIncDither"> Dither</label>
          <label><input type="checkbox" id="foIncSnes"> SNES Snap</label>
          <label><input type="checkbox" id="foIncRemoveBg"> Remove BG</label>
          <label><input type="checkbox" id="foIncScale"> Scale</label>
          <label class="fo-retouched-wrap">
            <input type="checkbox" id="foIncRetouched"> Retouched
            <span class="fo-dirty-dot" id="foDirtyDot" title="No retouching"></span>
          </label>
        </div>
      </div>

      <div class="fo-preview">
        <span class="fo-filename" id="foFilenamePreview">portrait.png</span>
        <button class="btn primary btn-save" id="foSave" disabled>Download PNG</button>
      </div>
    </div>
  </div>
</div>

<div class="status-bar">
  <div class="indicator">
    <span class="dot" style="background:var(--success)"></span>
    <span>Algorithmic pipeline (no generative AI)</span>
  </div>
</div>

<!-- MediaPipe -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm/vision_bundle.mjs" type="module"></script>
<script type="module">

// ============================================================
// Browser-side Pixel Portrait Pipeline
// ============================================================

class PixelPortrait {
  constructor() {
    this.faceLandmarker = null;
    this.ready = false;
  }

  async init() {
    try {
      const { FaceLandmarker, FilesetResolver } = await import(
        'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14'
      );

      const filesetResolver = await FilesetResolver.forVisionTasks(
        'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm'
      );

      this.faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
        baseOptions: {
          modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',
          delegate: 'GPU',
        },
        runningMode: 'IMAGE',
        numFaces: 1,
      });

      this.ready = true;
      console.log('PixelPortrait: MediaPipe FaceLandmarker ready');
    } catch (err) {
      console.error('PixelPortrait: Failed to init MediaPipe:', err);
      this.ready = false;
    }
  }

  async detectFace(imageSource) {
    const img = await this._loadImage(imageSource);
    const srcCanvas = document.createElement('canvas');
    srcCanvas.width = img.width;
    srcCanvas.height = img.height;
    srcCanvas.getContext('2d').drawImage(img, 0, 0);

    if (!this.faceLandmarker) return null;

    const result = this.faceLandmarker.detect(srcCanvas);
    if (!result.faceLandmarks || result.faceLandmarks.length === 0) return null;

    const landmarks = result.faceLandmarks[0];
    const bbox = this._getBoundingBox(landmarks, img.width, img.height);

    const eyeL = landmarks[33];
    const eyeR = landmarks[263];
    const angle = Math.atan2(
      eyeR.y * img.height - eyeL.y * img.height,
      eyeR.x * img.width - eyeL.x * img.width
    );

    const cx = bbox.x + bbox.w / 2;
    const cy = bbox.y + bbox.h / 2;
    const size = Math.max(bbox.w, bbox.h);

    return { landmarks, cx, cy, size, angle, imgW: img.width, imgH: img.height };
  }

  async process(imageSource, options = {}) {
    const {
      outputSize = 64,
      paletteColors = 16,
      snesSnap = true,
      dither = 'none',
      removeBg = false,
      bgThreshold = 0.5,
      cropOverride = null,
    } = options;

    const t0 = performance.now();

    // Load image into canvas
    const img = await this._loadImage(imageSource);
    const srcCanvas = document.createElement('canvas');
    srcCanvas.width = img.width;
    srcCanvas.height = img.height;
    const srcCtx = srcCanvas.getContext('2d');
    srcCtx.drawImage(img, 0, 0);

    // 1. Face detection (or use crop override)
    let landmarks = null;
    let bbox = null;
    let angle = 0;

    if (cropOverride) {
      landmarks = cropOverride.landmarks;
      angle = cropOverride.angle;
      bbox = {
        x: cropOverride.cx - cropOverride.size / 2,
        y: cropOverride.cy - cropOverride.size / 2,
        w: cropOverride.size,
        h: cropOverride.size,
      };
    } else {
      if (this.faceLandmarker) {
        const result = this.faceLandmarker.detect(srcCanvas);
        if (result.faceLandmarks && result.faceLandmarks.length > 0) {
          landmarks = result.faceLandmarks[0];
          bbox = this._getBoundingBox(landmarks, img.width, img.height);
        }
      }
      if (!bbox) {
        throw new Error('No face detected');
      }
      const eyeL = landmarks[33];
      const eyeR = landmarks[263];
      angle = Math.atan2(
        eyeR.y * img.height - eyeL.y * img.height,
        eyeR.x * img.width - eyeL.x * img.width
      );
    }

    // 2. Crop & align
    const cropCanvas = document.createElement('canvas');
    cropCanvas.width = 256;
    cropCanvas.height = 256;
    const cropCtx = cropCanvas.getContext('2d');

    cropCtx.save();
    cropCtx.translate(128, 128);
    cropCtx.rotate(-angle);
    cropCtx.drawImage(
      srcCanvas,
      bbox.x, bbox.y, bbox.w, bbox.h,
      -128, -128, 256, 256
    );
    cropCtx.restore();

    // 3. Pre-process: blur + contrast + saturation boost
    let imageData = cropCtx.getImageData(0, 0, 256, 256);
    imageData = this._gaussianBlur(imageData, 1);
    imageData = this._adjustContrast(imageData, 1.10);
    imageData = this._adjustSaturation(imageData, 1.15);
    cropCtx.putImageData(imageData, 0, 0);

    // 4. Downscale to output size
    const outCanvas = document.createElement('canvas');
    outCanvas.width = outputSize;
    outCanvas.height = outputSize;
    const outCtx = outCanvas.getContext('2d');
    outCtx.imageSmoothingEnabled = false;
    outCtx.drawImage(cropCanvas, 0, 0, outputSize, outputSize);

    // 4b. Background removal (optional, before quantization)
    if (removeBg) {
      let bgData = outCtx.getImageData(0, 0, outputSize, outputSize);
      bgData = this._removeBackground(bgData, landmarks, bbox, img.width, img.height, outputSize, bgThreshold);
      outCtx.putImageData(bgData, 0, 0);
    }

    // 5. Color quantization (simple k-means in JS)
    let outData = outCtx.getImageData(0, 0, outputSize, outputSize);
    const { quantized, palette } = this._quantize(outData, paletteColors);

    // Apply SNES snap
    const finalPalette = snesSnap
      ? palette.map(c => c.map(v => Math.round(v / 8) * 8))
      : palette;

    // Remap pixels to snapped palette
    for (let i = 0; i < quantized.data.length; i += 4) {
      const r = quantized.data[i], g = quantized.data[i+1], b = quantized.data[i+2];
      // Find nearest in original palette, then use snapped version
      let bestIdx = 0, bestDist = Infinity;
      for (let j = 0; j < palette.length; j++) {
        const dr = r - palette[j][0], dg = g - palette[j][1], db = b - palette[j][2];
        const d = dr*dr + dg*dg + db*db;
        if (d < bestDist) { bestDist = d; bestIdx = j; }
      }
      quantized.data[i] = Math.min(248, Math.max(0, finalPalette[bestIdx][0]));
      quantized.data[i+1] = Math.min(248, Math.max(0, finalPalette[bestIdx][1]));
      quantized.data[i+2] = Math.min(248, Math.max(0, finalPalette[bestIdx][2]));
    }

    outCtx.putImageData(quantized, 0, 0);

    // 6. Post-process: eye highlights + orphan cleanup
    let finalData = outCtx.getImageData(0, 0, outputSize, outputSize);
    finalData = this._injectEyeHighlights(finalData, landmarks, bbox, outputSize, finalPalette);
    finalData = this._cleanupOrphans(finalData, outputSize);
    outCtx.putImageData(finalData, 0, 0);

    const elapsed = performance.now() - t0;

    return {
      canvas: outCanvas,
      palette: finalPalette,
      processingMs: Math.round(elapsed),
      outputSize,
    };
  }

  _loadImage(source) {
    return new Promise((resolve, reject) => {
      if (source instanceof HTMLImageElement) { resolve(source); return; }
      if (source instanceof HTMLCanvasElement) {
        const img = new Image();
        img.onload = () => resolve(img);
        img.src = source.toDataURL();
        return;
      }
      // File or Blob
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      if (source instanceof File || source instanceof Blob) {
        img.src = URL.createObjectURL(source);
      } else if (typeof source === 'string') {
        img.src = source;
      } else {
        reject(new Error('Unknown source type'));
      }
    });
  }

  _getBoundingBox(landmarks, w, h) {
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    for (const lm of landmarks) {
      const x = lm.x * w, y = lm.y * h;
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
    }
    // Expand by 35%
    const bw = maxX - minX, bh = maxY - minY;
    const padX = bw * 0.35, padY = bh * 0.35;
    return {
      x: Math.max(0, minX - padX),
      y: Math.max(0, minY - padY),
      w: Math.min(w, maxX + padX) - Math.max(0, minX - padX),
      h: Math.min(h, maxY + padY) - Math.max(0, minY - padY),
    };
  }

  _gaussianBlur(imageData, sigma) {
    // Simple 3x3 box blur approximation
    const w = imageData.width, h = imageData.height;
    const src = new Uint8ClampedArray(imageData.data);
    const dst = imageData.data;
    for (let y = 1; y < h - 1; y++) {
      for (let x = 1; x < w - 1; x++) {
        for (let c = 0; c < 3; c++) {
          let sum = 0;
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              sum += src[((y+dy)*w + (x+dx))*4 + c];
            }
          }
          dst[(y*w + x)*4 + c] = sum / 9;
        }
      }
    }
    return imageData;
  }

  _adjustContrast(imageData, factor) {
    const d = imageData.data;
    for (let i = 0; i < d.length; i += 4) {
      d[i]   = Math.min(255, Math.max(0, ((d[i] - 128) * factor) + 128));
      d[i+1] = Math.min(255, Math.max(0, ((d[i+1] - 128) * factor) + 128));
      d[i+2] = Math.min(255, Math.max(0, ((d[i+2] - 128) * factor) + 128));
    }
    return imageData;
  }

  _adjustSaturation(imageData, factor) {
    const d = imageData.data;
    for (let i = 0; i < d.length; i += 4) {
      const r = d[i], g = d[i+1], b = d[i+2];
      const gray = 0.2126 * r + 0.7152 * g + 0.0722 * b;
      d[i]   = Math.min(255, Math.max(0, gray + (r - gray) * factor));
      d[i+1] = Math.min(255, Math.max(0, gray + (g - gray) * factor));
      d[i+2] = Math.min(255, Math.max(0, gray + (b - gray) * factor));
    }
    return imageData;
  }

  _quantize(imageData, nColors) {
    const w = imageData.width, h = imageData.height;
    const pixels = [];
    for (let i = 0; i < imageData.data.length; i += 4) {
      pixels.push([imageData.data[i], imageData.data[i+1], imageData.data[i+2]]);
    }

    // Simple k-means
    // Initialize centroids with k-means++ style
    const centroids = [pixels[Math.floor(Math.random() * pixels.length)].slice()];
    for (let k = 1; k < nColors; k++) {
      let maxDist = -1, bestPixel = pixels[0];
      for (const p of pixels) {
        let minD = Infinity;
        for (const c of centroids) {
          const d = (p[0]-c[0])**2 + (p[1]-c[1])**2 + (p[2]-c[2])**2;
          if (d < minD) minD = d;
        }
        if (minD > maxDist) { maxDist = minD; bestPixel = p; }
      }
      centroids.push(bestPixel.slice());
    }

    // Run k-means iterations
    const labels = new Int32Array(pixels.length);
    for (let iter = 0; iter < 10; iter++) {
      // Assign
      for (let i = 0; i < pixels.length; i++) {
        let bestD = Infinity, bestK = 0;
        for (let k = 0; k < centroids.length; k++) {
          const dr = pixels[i][0] - centroids[k][0];
          const dg = pixels[i][1] - centroids[k][1];
          const db = pixels[i][2] - centroids[k][2];
          const d = dr*dr + dg*dg + db*db;
          if (d < bestD) { bestD = d; bestK = k; }
        }
        labels[i] = bestK;
      }
      // Update centroids
      const sums = Array.from({length: nColors}, () => [0, 0, 0, 0]); // r,g,b,count
      for (let i = 0; i < pixels.length; i++) {
        const k = labels[i];
        sums[k][0] += pixels[i][0];
        sums[k][1] += pixels[i][1];
        sums[k][2] += pixels[i][2];
        sums[k][3]++;
      }
      for (let k = 0; k < nColors; k++) {
        if (sums[k][3] > 0) {
          centroids[k][0] = sums[k][0] / sums[k][3];
          centroids[k][1] = sums[k][1] / sums[k][3];
          centroids[k][2] = sums[k][2] / sums[k][3];
        }
      }
    }

    // Map pixels to centroids
    const result = new ImageData(w, h);
    for (let i = 0; i < pixels.length; i++) {
      const k = labels[i];
      result.data[i*4]   = Math.round(centroids[k][0]);
      result.data[i*4+1] = Math.round(centroids[k][1]);
      result.data[i*4+2] = Math.round(centroids[k][2]);
      result.data[i*4+3] = 255;
    }

    const palette = centroids.map(c => c.map(v => Math.round(v)));
    return { quantized: result, palette };
  }

  _injectEyeHighlights(imageData, landmarks, bbox, outputSize, palette) {
    if (!landmarks || !palette.length) return imageData;

    // Find brightest color
    let brightest = palette[0], brightLum = 0;
    for (const c of palette) {
      const lum = 0.2126 * c[0] + 0.7152 * c[1] + 0.0722 * c[2];
      if (lum > brightLum) { brightLum = lum; brightest = c; }
    }

    const d = imageData.data;
    const w = outputSize;

    for (const eyeIdx of [33, 263]) {
      const lm = landmarks[eyeIdx];
      // Map from image coords to crop coords to output coords
      const relX = (lm.x * (bbox.w + bbox.x * 2 / bbox.w) - bbox.x) / bbox.w;
      const relY = (lm.y * (bbox.h + bbox.y * 2 / bbox.h) - bbox.y) / bbox.h;
      const px = Math.round(Math.max(0, Math.min(w - 1,
        ((lm.x * w * 4) - bbox.x) / bbox.w * outputSize / 4
      )));
      const py = Math.round(Math.max(0, Math.min(w - 1,
        ((lm.y * w * 4) - bbox.y) / bbox.h * outputSize / 4
      )));

      // Check for existing bright pixel
      let hasBright = false;
      for (let dy = -1; dy <= 1 && !hasBright; dy++) {
        for (let dx = -1; dx <= 1 && !hasBright; dx++) {
          const nx = px + dx, ny = py + dy;
          if (nx >= 0 && nx < w && ny >= 0 && ny < w) {
            const idx = (ny * w + nx) * 4;
            const lum = (0.2126 * d[idx] + 0.7152 * d[idx+1] + 0.0722 * d[idx+2]) / 255;
            if (lum > 0.7) hasBright = true;
          }
        }
      }

      if (!hasBright && px >= 0 && px < w && py >= 0 && py < w) {
        const idx = (py * w + px) * 4;
        d[idx] = brightest[0];
        d[idx+1] = brightest[1];
        d[idx+2] = brightest[2];
      }
    }

    return imageData;
  }

  _removeBackground(imageData, landmarks, bbox, imgW, imgH, outputSize, threshold) {
    const w = imageData.width;
    const h = outputSize;
    const d = imageData.data;

    // 1. Convert to grayscale for edge detection
    const gray = new Float32Array(w * h);
    for (let i = 0; i < w * h; i++) {
      gray[i] = 0.299 * d[i*4] + 0.587 * d[i*4+1] + 0.114 * d[i*4+2];
    }

    // 2. Sobel gradient magnitude
    const grad = new Float32Array(w * h);
    for (let y = 1; y < h - 1; y++) {
      for (let x = 1; x < w - 1; x++) {
        const tl = gray[(y-1)*w+(x-1)], tc = gray[(y-1)*w+x], tr = gray[(y-1)*w+(x+1)];
        const ml = gray[y*w+(x-1)],                            mr = gray[y*w+(x+1)];
        const bl = gray[(y+1)*w+(x-1)], bc = gray[(y+1)*w+x], br = gray[(y+1)*w+(x+1)];
        const gx = -tl + tr - 2*ml + 2*mr - bl + br;
        const gy = -tl - 2*tc - tr + bl + 2*bc + br;
        grad[y*w+x] = Math.sqrt(gx*gx + gy*gy);
      }
    }
    // Border pixels get max gradient so flood fill can start but won't leak through corners
    for (let x = 0; x < w; x++) { grad[x] = 0; grad[(h-1)*w+x] = 0; }
    for (let y = 0; y < h; y++) { grad[y*w] = 0; grad[y*w+(w-1)] = 0; }

    // 3. Face ellipse â€” protected foreground zone
    const eyeL = landmarks[33];
    const eyeR = landmarks[263];
    const mouth = landmarks[13];
    const mapX = (lm) => ((lm.x * imgW - bbox.x) / bbox.w) * outputSize;
    const mapY = (lm) => ((lm.y * imgH - bbox.y) / bbox.h) * outputSize;
    const elX = mapX(eyeL), elY = mapY(eyeL);
    const erX = mapX(eyeR), erY = mapY(eyeR);
    const mY = mapY(mouth);
    const cx = (elX + erX) / 2;
    const cy = (elY + mY) / 2;
    const eyeDist = Math.abs(erX - elX);
    const prx = eyeDist * 0.55;
    const pry = prx * 1.3;

    const protect = new Uint8Array(w * h);
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const ex = (x - cx) / prx;
        const ey = (y - cy) / pry;
        if (ex*ex + ey*ey < 1.0) protect[y*w+x] = 1;
      }
    }

    // 4. Edge threshold: threshold=0 aggressive (high cutoff), threshold=1 conservative (low cutoff)
    const edgeCutoff = 20 + (1.0 - threshold) * 60;

    // 5. BFS flood fill from all border pixels
    const bg = new Uint8Array(w * h); // 1 = background
    const queue = [];
    for (let x = 0; x < w; x++) {
      if (!protect[x])           { bg[x] = 1; queue.push(x); }
      if (!protect[(h-1)*w+x])   { bg[(h-1)*w+x] = 1; queue.push((h-1)*w+x); }
    }
    for (let y = 1; y < h - 1; y++) {
      if (!protect[y*w])         { bg[y*w] = 1; queue.push(y*w); }
      if (!protect[y*w+(w-1)])   { bg[y*w+(w-1)] = 1; queue.push(y*w+(w-1)); }
    }

    let qi = 0;
    while (qi < queue.length) {
      const idx = queue[qi++];
      const px = idx % w, py = (idx - px) / w;
      const neighbors = [];
      if (px > 0)     neighbors.push(idx - 1);
      if (px < w - 1) neighbors.push(idx + 1);
      if (py > 0)     neighbors.push(idx - w);
      if (py < h - 1) neighbors.push(idx + w);
      for (const ni of neighbors) {
        if (bg[ni] || protect[ni]) continue;
        if (grad[ni] < edgeCutoff) {
          bg[ni] = 1;
          queue.push(ni);
        }
      }
    }

    // 6. Make background pixels transparent
    for (let i = 0; i < w * h; i++) {
      if (bg[i]) {
        d[i*4] = 0;
        d[i*4+1] = 0;
        d[i*4+2] = 0;
        d[i*4+3] = 0;
      }
    }

    return imageData;
  }

  _cleanupOrphans(imageData, size) {
    const d = imageData.data;
    const w = size;
    const result = new Uint8ClampedArray(d);

    for (let y = 1; y < w - 1; y++) {
      for (let x = 1; x < w - 1; x++) {
        const ci = (y * w + x) * 4;
        const cr = d[ci], cg = d[ci+1], cb = d[ci+2];

        // Cardinal neighbors
        const ti = ((y-1)*w + x)*4, bi = ((y+1)*w + x)*4;
        const li = (y*w + (x-1))*4, ri = (y*w + (x+1))*4;

        const tr = d[ti], tg = d[ti+1], tb = d[ti+2];

        // All 4 same?
        if (
          tr === d[bi] && tg === d[bi+1] && tb === d[bi+2] &&
          tr === d[li] && tg === d[li+1] && tb === d[li+2] &&
          tr === d[ri] && tg === d[ri+1] && tb === d[ri+2]
        ) {
          // Current differs?
          if (cr !== tr || cg !== tg || cb !== tb) {
            result[ci] = tr;
            result[ci+1] = tg;
            result[ci+2] = tb;
          }
        }
      }
    }

    imageData.data.set(result);
    return imageData;
  }
}


// ============================================================
// UI Controller
// ============================================================

const portrait = new PixelPortrait();

const fileInput = document.getElementById('fileInput');
const dropZone = document.getElementById('dropZone');
const sourcePreview = document.getElementById('sourcePreview');
const btnUpload = document.getElementById('btnUpload');
const btnDownload = document.getElementById('btnDownload');
const btnDownloadAll = document.getElementById('btnDownloadAll');
const browserCanvas = document.getElementById('browserCanvas');
const browserDot = document.getElementById('browserDot');
const browserSpinner = document.getElementById('browserSpinner');
const canvasWrap = document.getElementById('canvasWrap');
const brushCursor = document.getElementById('brushCursor');
const btnUndo = document.getElementById('btnUndo');
const btnRedo = document.getElementById('btnRedo');
const undoCountEl = document.getElementById('undoCount');
const redoCountEl = document.getElementById('redoCount');
const activeBrushPreview = document.getElementById('activeBrushPreview');
const btnEyedropper = document.getElementById('btnEyedropper');

let currentFile = null;
let browserResult = null;

// ============================================================
// Crop Overlay System
// ============================================================

let detectedCrop = null;     // result from portrait.detectFace()
let cropRotationOffset = 0;  // degrees, user adjustment
let cropSizeScale = 1.0;     // multiplier, user adjustment

const cropControls = document.getElementById('cropControls');
const cropRotationSlider = document.getElementById('cropRotation');
const cropRotationVal = document.getElementById('cropRotationVal');
const cropSizeSlider = document.getElementById('cropSize');
const cropSizeVal = document.getElementById('cropSizeVal');

function getCropOverride() {
  if (!detectedCrop) return null;
  const angleOffset = cropRotationOffset * Math.PI / 180;
  return {
    landmarks: detectedCrop.landmarks,
    cx: detectedCrop.cx,
    cy: detectedCrop.cy,
    size: detectedCrop.size * cropSizeScale,
    angle: detectedCrop.angle + angleOffset,
  };
}

function drawCropOverlay() {
  if (!detectedCrop) return;

  const preview = document.getElementById('sourcePreview');
  const imgEl = preview.querySelector('img');
  if (!imgEl) return;

  // Remove existing overlay
  let overlay = preview.querySelector('.crop-overlay');
  if (!overlay) {
    overlay = document.createElement('canvas');
    overlay.className = 'crop-overlay';
    preview.appendChild(overlay);
  }

  // Match overlay to the displayed image dimensions
  const imgRect = imgEl.getBoundingClientRect();
  const previewRect = preview.getBoundingClientRect();
  overlay.width = imgRect.width;
  overlay.height = imgRect.height;
  overlay.style.width = imgRect.width + 'px';
  overlay.style.height = imgRect.height + 'px';
  overlay.style.left = (imgRect.left - previewRect.left) + 'px';
  overlay.style.top = (imgRect.top - previewRect.top) + 'px';

  const ctx = overlay.getContext('2d');
  ctx.clearRect(0, 0, overlay.width, overlay.height);

  // Map crop params from image coords to display coords
  const scaleX = imgRect.width / detectedCrop.imgW;
  const scaleY = imgRect.height / detectedCrop.imgH;

  const crop = getCropOverride();
  const cx = crop.cx * scaleX;
  const cy = crop.cy * scaleY;
  const halfSize = (crop.size / 2) * Math.max(scaleX, scaleY);
  const angle = crop.angle;

  // Draw dark mask with cutout
  ctx.save();
  ctx.fillStyle = 'rgba(0, 0, 0, 0.55)';
  ctx.fillRect(0, 0, overlay.width, overlay.height);

  // Cut out the rotated square
  ctx.globalCompositeOperation = 'destination-out';
  ctx.translate(cx, cy);
  ctx.rotate(-angle);
  ctx.fillStyle = 'white';
  ctx.fillRect(-halfSize, -halfSize, halfSize * 2, halfSize * 2);
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.globalCompositeOperation = 'source-over';

  // Draw crop border
  ctx.strokeStyle = 'rgba(233, 69, 96, 0.9)';
  ctx.lineWidth = 2;
  ctx.translate(cx, cy);
  ctx.rotate(-angle);
  ctx.strokeRect(-halfSize, -halfSize, halfSize * 2, halfSize * 2);

  // Draw center crosshair
  ctx.strokeStyle = 'rgba(233, 69, 96, 0.5)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-6, 0); ctx.lineTo(6, 0);
  ctx.moveTo(0, -6); ctx.lineTo(0, 6);
  ctx.stroke();

  ctx.restore();
}

// Crop slider handlers
cropRotationSlider.addEventListener('input', () => {
  cropRotationOffset = parseInt(cropRotationSlider.value);
  cropRotationVal.textContent = cropRotationOffset + '\u00b0';
  drawCropOverlay();
  scheduleRerun();
});

cropSizeSlider.addEventListener('input', () => {
  cropSizeScale = parseInt(cropSizeSlider.value) / 100;
  cropSizeVal.textContent = cropSizeSlider.value + '%';
  drawCropOverlay();
  scheduleRerun();
});

document.getElementById('btnCropReset').addEventListener('click', () => {
  cropRotationOffset = 0;
  cropSizeScale = 1.0;
  cropRotationSlider.value = 0;
  cropRotationVal.textContent = '0\u00b0';
  cropSizeSlider.value = 100;
  cropSizeVal.textContent = '100%';
  drawCropOverlay();
  scheduleRerun();
});

// Redraw overlay when window resizes (image display size may change)
window.addEventListener('resize', () => { if (detectedCrop) drawCropOverlay(); });

// ============================================================
// Zoom System
// ============================================================

let currentZoom = 1.0;
const ZOOM_MIN = 0.25;
const ZOOM_MAX = 8.0;
const ZOOM_STEP = 1.25;       // +/- button multiplier
const ZOOM_WHEEL_STEP = 1.08; // scroll wheel multiplier per tick

const zoomSlider = document.getElementById('zoomSlider');
const zoomPctEl = document.getElementById('zoomPct');
const zoomInvertCheckbox = document.getElementById('zoomInvert');

function applyZoom() {
  const cssW = browserCanvas.width * currentZoom;
  const cssH = browserCanvas.height * currentZoom;
  browserCanvas.style.width = cssW + 'px';
  browserCanvas.style.height = cssH + 'px';
  const pct = Math.round(currentZoom * 100);
  zoomPctEl.textContent = pct + '%';
  zoomSlider.value = pct;
}

function setZoom(z) {
  currentZoom = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, z));
  applyZoom();
}

document.getElementById('zoomIn').addEventListener('click', () => setZoom(currentZoom * ZOOM_STEP));
document.getElementById('zoomOut').addEventListener('click', () => setZoom(currentZoom / ZOOM_STEP));
document.getElementById('zoomReset').addEventListener('click', () => setZoom(1.0));

zoomSlider.addEventListener('input', () => {
  setZoom(parseInt(zoomSlider.value) / 100);
});

// Scroll wheel zoom (centered on cursor)
canvasWrap.addEventListener('wheel', (e) => {
  e.preventDefault();

  const invert = zoomInvertCheckbox.checked;
  const delta = invert ? e.deltaY : -e.deltaY;
  const factor = delta > 0 ? ZOOM_WHEEL_STEP : 1 / ZOOM_WHEEL_STEP;
  const newZoom = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, currentZoom * factor));
  if (newZoom === currentZoom) return;

  // Zoom centered on mouse position
  const wrapRect = canvasWrap.getBoundingClientRect();
  const mouseX = e.clientX - wrapRect.left;
  const mouseY = e.clientY - wrapRect.top;

  // Point in content space before zoom
  const contentX = mouseX + canvasWrap.scrollLeft;
  const contentY = mouseY + canvasWrap.scrollTop;

  // Scale to new zoom
  const ratio = newZoom / currentZoom;
  currentZoom = newZoom;
  applyZoom();

  // Scroll to keep the same content point under the mouse
  canvasWrap.scrollLeft = contentX * ratio - mouseX;
  canvasWrap.scrollTop = contentY * ratio - mouseY;
}, { passive: false });

// ============================================================
// Retouch Dirty Tracking
// ============================================================

let retouchDirty = false;
let algorithmSnapshot = null;

function setRetouchDirty(dirty) {
  retouchDirty = dirty;
  const dot = document.getElementById('foDirtyDot');
  dot.classList.toggle('dirty', dirty);
  dot.title = dirty ? 'Canvas has been retouched' : 'No retouching';
  updateFilenamePreview();
}

function storeAlgorithmSnapshot() {
  const ctx = browserCanvas.getContext('2d');
  algorithmSnapshot = ctx.getImageData(0, 0, browserCanvas.width, browserCanvas.height);
}

function compareToAlgorithmSnapshot() {
  if (!algorithmSnapshot) return false;
  const ctx = browserCanvas.getContext('2d');
  const current = ctx.getImageData(0, 0, browserCanvas.width, browserCanvas.height);
  if (current.width !== algorithmSnapshot.width || current.height !== algorithmSnapshot.height) {
    return false;
  }
  const a = current.data;
  const b = algorithmSnapshot.data;
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}

// Init
portrait.init().then(() => {
  console.log('Browser pipeline ready');
});

// Load palettes
fetch('/api/palettes')
  .then(r => r.json())
  .then(data => {
    const select = document.getElementById('paletteName');
    for (const p of data.palettes) {
      const opt = document.createElement('option');
      opt.value = p.slug;
      opt.textContent = `${p.name} (${p.colors.length})`;
      select.appendChild(opt);
    }
  })
  .catch(() => console.warn('Could not load palettes from server'));

// File input
btnUpload.addEventListener('click', () => fileInput.click());
dropZone.addEventListener('click', () => fileInput.click());

dropZone.addEventListener('dragover', e => {
  e.preventDefault();
  dropZone.classList.add('dragover');
});
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
dropZone.addEventListener('drop', e => {
  e.preventDefault();
  dropZone.classList.remove('dragover');
  if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
});
fileInput.addEventListener('change', () => {
  if (fileInput.files.length) handleFile(fileInput.files[0]);
});

// Camera
document.getElementById('btnCamera').addEventListener('click', async () => {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } });
    const video = document.createElement('video');
    video.srcObject = stream;
    video.autoplay = true;
    video.playsInline = true;
    await new Promise(r => video.onloadedmetadata = r);
    await video.play();

    const c = document.createElement('canvas');
    c.width = video.videoWidth;
    c.height = video.videoHeight;
    c.getContext('2d').drawImage(video, 0, 0);
    stream.getTracks().forEach(t => t.stop());

    c.toBlob(blob => handleFile(new File([blob], 'camera.jpg', { type: 'image/jpeg' })), 'image/jpeg');
  } catch (err) {
    alert('Camera access denied: ' + err.message);
  }
});

function updateExportSize() {
  const s = getSettings();
  const px = s.outputSize * s.scale;
  document.getElementById('exportSize').textContent = `${px} \u00d7 ${px}`;
  applyZoom();
}

// Debounced re-render: waits for rapid changes to settle before re-running
let _rerunTimer = null;
function scheduleRerun() {
  if (!currentFile) return;
  clearTimeout(_rerunTimer);
  _rerunTimer = setTimeout(() => {
    pushUndo();
    clearRedo();
    runBrowserPipeline(currentFile);
  }, 80);
}

// Rescale canvas without re-running pipeline (preserves retouches)
function rescaleCanvas() {
  if (!browserResult) return;
  const settings = getSettings();
  const outputSize = settings.outputSize;
  const newSize = outputSize * settings.scale;

  // Helper: rescale a snapshot's imageData to a new display size
  function rescaleSnapshot(snap) {
    const tmp = document.createElement('canvas');
    tmp.width = snap.width;
    tmp.height = snap.height;
    const tc = tmp.getContext('2d');
    tc.putImageData(snap.imageData, 0, 0);

    const out = document.createElement('canvas');
    out.width = newSize;
    out.height = newSize;
    const oc = out.getContext('2d');
    oc.imageSmoothingEnabled = false;
    // Downscale to pixel art resolution, then upscale to new display size
    oc.drawImage(tmp, 0, 0, newSize, newSize);

    return {
      imageData: oc.getImageData(0, 0, newSize, newSize),
      width: newSize,
      height: newSize,
    };
  }

  // Rescale all undo/redo snapshots
  for (let i = 0; i < undoStack.length; i++) {
    undoStack[i] = rescaleSnapshot(undoStack[i]);
  }
  for (let i = 0; i < redoStack.length; i++) {
    redoStack[i] = rescaleSnapshot(redoStack[i]);
  }

  // Rescale the current canvas
  const rawCanvas = document.createElement('canvas');
  rawCanvas.width = outputSize;
  rawCanvas.height = outputSize;
  const rawCtx = rawCanvas.getContext('2d');
  rawCtx.imageSmoothingEnabled = false;
  rawCtx.drawImage(browserCanvas, 0, 0, outputSize, outputSize);

  browserCanvas.width = newSize;
  browserCanvas.height = newSize;
  const ctx = browserCanvas.getContext('2d');
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(rawCanvas, 0, 0, newSize, newSize);

  // Rescale algorithm snapshot for dirty tracking
  if (algorithmSnapshot) {
    const snap = rescaleSnapshot({
      imageData: algorithmSnapshot,
      width: algorithmSnapshot.width,
      height: algorithmSnapshot.height,
    });
    algorithmSnapshot = snap.imageData;
  }
  updateExportSize();
}

// Remove BG toggle â€” show/hide threshold slider + live re-render
const removeBgCheckbox = document.getElementById('removeBg');
const bgThresholdControl = document.getElementById('bgThresholdControl');
const bgThresholdSlider = document.getElementById('bgThreshold');
const bgThresholdVal = document.getElementById('bgThresholdVal');

removeBgCheckbox.addEventListener('change', () => {
  bgThresholdControl.style.display = removeBgCheckbox.checked ? 'flex' : 'none';
  scheduleRerun();
});

bgThresholdSlider.addEventListener('input', () => {
  bgThresholdVal.textContent = bgThresholdSlider.value;
  scheduleRerun();
});

// All settings (except scale) â†’ live re-render on any change
for (const id of ['outputSize', 'paletteColors', 'paletteName', 'dither', 'snesSnap']) {
  const el = document.getElementById(id);
  el.addEventListener('change', scheduleRerun);
  el.addEventListener('input', scheduleRerun);
}

// Scale â†’ rescale display only (preserves retouches)
document.getElementById('scale').addEventListener('change', rescaleCanvas);

async function handleFile(file) {
  currentFile = file;

  // Show preview
  const url = URL.createObjectURL(file);
  sourcePreview.innerHTML = `<img src="${url}" alt="Source">`;

  // Clear undo/redo stacks on new image
  undoStack.length = 0;
  redoStack.length = 0;
  updateHistoryUI();

  // Reset retouch tracking
  setRetouchDirty(false);
  algorithmSnapshot = null;

  // Set root file name from source filename
  const baseName = file.name.replace(/\.[^.]+$/, '');
  document.getElementById('foRootName').value = baseName + '_16bit';
  updateFilenamePreview();

  // Reset crop adjustments for new image
  cropRotationOffset = 0;
  cropSizeScale = 1.0;
  cropRotationSlider.value = 0;
  cropRotationVal.textContent = '0\u00b0';
  cropSizeSlider.value = 100;
  cropSizeVal.textContent = '100%';

  // Detect face and show crop overlay
  detectedCrop = await portrait.detectFace(file);
  if (detectedCrop) {
    cropControls.classList.add('visible');
    // Wait for image to load in DOM before drawing overlay
    const imgEl = sourcePreview.querySelector('img');
    if (imgEl.complete) {
      drawCropOverlay();
    } else {
      imgEl.addEventListener('load', () => drawCropOverlay(), { once: true });
    }
  } else {
    cropControls.classList.remove('visible');
  }

  // Run browser pipeline immediately
  await runBrowserPipeline(file);
}

function getSettings() {
  return {
    outputSize: parseInt(document.getElementById('outputSize').value),
    paletteColors: parseInt(document.getElementById('paletteColors').value),
    paletteName: document.getElementById('paletteName').value,
    dither: document.getElementById('dither').value,
    snesSnap: document.getElementById('snesSnap').checked,
    removeBg: removeBgCheckbox.checked,
    bgThreshold: parseFloat(bgThresholdSlider.value),
    scale: parseInt(document.getElementById('scale').value),
  };
}

async function runBrowserPipeline(file) {
  browserDot.classList.add('processing');
  browserSpinner.classList.add('show');

  try {
    const settings = getSettings();
    const result = await portrait.process(file, {
      outputSize: settings.outputSize,
      paletteColors: settings.paletteColors,
      snesSnap: settings.snesSnap,
      dither: settings.dither,
      removeBg: settings.removeBg,
      bgThreshold: settings.bgThreshold,
      cropOverride: getCropOverride(),
    });

    // Draw to display canvas (upscaled)
    const displaySize = settings.outputSize * settings.scale;
    browserCanvas.width = displaySize;
    browserCanvas.height = displaySize;
    const ctx = browserCanvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(result.canvas, 0, 0, displaySize, displaySize);

    // Update meta
    document.getElementById('browserTime').textContent = `${result.processingMs}ms`;
    document.getElementById('browserColorCount').textContent = result.palette.length;
    updateExportSize();

    // Swatches (clickable for brush)
    clearBrush();
    buildSwatches(document.getElementById('browserSwatches'), result.palette, 'rgb');

    browserDot.className = 'dot active';
    browserResult = browserCanvas;
    btnDownload.disabled = false;
    btnDownloadAll.disabled = false;

    // Reset retouch tracking â€” algorithm just produced fresh output
    setRetouchDirty(false);
    storeAlgorithmSnapshot();
    updateSaveEnabled();
    updateFilenamePreview();
  } catch (err) {
    console.error('Browser pipeline error:', err);
    document.getElementById('browserTime').textContent = `Error: ${err.message}`;
    browserDot.className = 'dot';
    updateSaveEnabled();
  }

  browserSpinner.classList.remove('show');
}

// Download (current scale)
btnDownload.addEventListener('click', () => {
  if (browserResult) {
    const link = document.createElement('a');
    const s = getSettings();
    link.download = `portrait-${s.outputSize}px-${s.scale}x.png`;
    link.href = browserResult.toDataURL('image/png');
    link.click();
  }
});

// Download all sizes
btnDownloadAll.addEventListener('click', () => {
  if (!browserResult) return;
  const outputSize = getSettings().outputSize;

  // Extract raw pixel art at outputSize resolution from the display canvas
  const rawCanvas = document.createElement('canvas');
  rawCanvas.width = outputSize;
  rawCanvas.height = outputSize;
  const rawCtx = rawCanvas.getContext('2d');
  rawCtx.imageSmoothingEnabled = false;
  rawCtx.drawImage(browserCanvas, 0, 0, outputSize, outputSize);

  const scales = [4, 8, 12, 16];
  scales.forEach((scale, i) => {
    setTimeout(() => {
      const size = outputSize * scale;
      const c = document.createElement('canvas');
      c.width = size;
      c.height = size;
      const ctx = c.getContext('2d');
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(rawCanvas, 0, 0, size, size);
      const link = document.createElement('a');
      link.download = `portrait-${outputSize}px-${scale}x.png`;
      link.href = c.toDataURL('image/png');
      link.click();
    }, i * 300); // stagger downloads so browser doesn't block them
  });
});


// ============================================================
// Undo / Redo System
// ============================================================

const MAX_HISTORY = 50;
const undoStack = [];
const redoStack = [];

function snapshotCanvas() {
  const ctx = browserCanvas.getContext('2d');
  return {
    imageData: ctx.getImageData(0, 0, browserCanvas.width, browserCanvas.height),
    width: browserCanvas.width,
    height: browserCanvas.height,
  };
}

function restoreSnapshot(state) {
  browserCanvas.width = state.width;
  browserCanvas.height = state.height;
  const ctx = browserCanvas.getContext('2d');
  ctx.imageSmoothingEnabled = false;
  ctx.putImageData(state.imageData, 0, 0);
  applyZoom();
}

function pushUndo() {
  if (!browserCanvas.width || !browserCanvas.height) return;
  undoStack.push(snapshotCanvas());
  if (undoStack.length > MAX_HISTORY) undoStack.shift();
  updateHistoryUI();
}

function clearRedo() {
  redoStack.length = 0;
  updateHistoryUI();
}

function popUndo() {
  if (undoStack.length === 0) return;
  // Save current state to redo before restoring
  redoStack.push(snapshotCanvas());
  if (redoStack.length > MAX_HISTORY) redoStack.shift();
  restoreSnapshot(undoStack.pop());
  updateHistoryUI();
  // Check if undo has reverted to the algorithm output
  if (compareToAlgorithmSnapshot()) {
    setRetouchDirty(false);
  }
}

function popRedo() {
  if (redoStack.length === 0) return;
  // Save current state to undo before restoring
  undoStack.push(snapshotCanvas());
  if (undoStack.length > MAX_HISTORY) undoStack.shift();
  restoreSnapshot(redoStack.pop());
  updateHistoryUI();
  setRetouchDirty(true);
}

function updateHistoryUI() {
  btnUndo.disabled = undoStack.length === 0;
  undoCountEl.textContent = undoStack.length;
  btnRedo.disabled = redoStack.length === 0;
  redoCountEl.textContent = redoStack.length;
}

btnUndo.addEventListener('click', popUndo);
btnRedo.addEventListener('click', popRedo);


// ============================================================
// Pixel Brush â€” click palette swatch to paint on canvas
// ============================================================

let activeBrush = null; // null | {r,g,b,a} where a=0 means transparent
let brushSize = 1;      // 1â€“4 pixel-art pixels

function clearBrush() {
  activeBrush = null;
  document.querySelectorAll('.palette-swatches .swatch').forEach(s => s.classList.remove('active'));
  browserCanvas.classList.remove('brush-active');
  brushCursor.style.display = 'none';
  updateBrushPreview();
}

function selectBrush(swatchEl, color) {
  if (swatchEl.classList.contains('active')) { clearBrush(); return; }
  clearBrush();
  activeBrush = color;
  swatchEl.classList.add('active');
  browserCanvas.classList.add('brush-active');
  updateBrushPreview();
}

function updateBrushPreview() {
  if (!activeBrush) {
    activeBrushPreview.innerHTML = '<span>No brush selected &mdash; click a swatch</span>';
    return;
  }
  const swatch = document.createElement('div');
  swatch.className = 'preview-swatch';
  if (activeBrush.a === 0) {
    swatch.classList.add('transparent');
  } else {
    swatch.style.background = `rgb(${activeBrush.r},${activeBrush.g},${activeBrush.b})`;
  }
  const label = activeBrush.a === 0 ? 'Transparent' : `rgb(${activeBrush.r}, ${activeBrush.g}, ${activeBrush.b})`;
  activeBrushPreview.innerHTML = '';
  activeBrushPreview.appendChild(swatch);
  activeBrushPreview.appendChild(document.createTextNode(`${label} @ ${brushSize}px`));
}

function setBrushSize(size) {
  brushSize = size;
  document.querySelectorAll('#sizeBtns .size-btn').forEach(b =>
    b.classList.toggle('active', parseInt(b.dataset.size) === size)
  );
  updateBrushPreview();
}

document.querySelectorAll('#sizeBtns .size-btn').forEach(b =>
  b.addEventListener('click', () => setBrushSize(parseInt(b.dataset.size)))
);

function buildSwatches(container, palette, source) {
  container.innerHTML = '';
  for (const c of palette) {
    const s = document.createElement('div');
    s.className = 'swatch';
    if (source === 'hex') {
      s.style.background = c;
      const rgb = hexToRgb(c);
      s.addEventListener('click', () => selectBrush(s, {r: rgb[0], g: rgb[1], b: rgb[2], a: 255}));
    } else {
      s.style.background = `rgb(${c[0]},${c[1]},${c[2]})`;
      s.addEventListener('click', () => selectBrush(s, {r: c[0], g: c[1], b: c[2], a: 255}));
    }
    container.appendChild(s);
  }
  const ts = document.createElement('div');
  ts.className = 'swatch transparent';
  ts.title = 'Transparent';
  ts.addEventListener('click', () => selectBrush(ts, {r: 0, g: 0, b: 0, a: 0}));
  container.appendChild(ts);
}

function hexToRgb(hex) {
  const h = hex.replace('#', '');
  return [parseInt(h.substring(0,2), 16), parseInt(h.substring(2,4), 16), parseInt(h.substring(4,6), 16)];
}


// ============================================================
// Brush Cursor Preview
// ============================================================

function canvasToPixel(canvas, event) {
  const rect = canvas.getBoundingClientRect();
  const sx = canvas.width / rect.width;
  const sy = canvas.height / rect.height;
  const cx = Math.floor((event.clientX - rect.left) * sx);
  const cy = Math.floor((event.clientY - rect.top) * sy);
  const settings = getSettings();
  const ps = Math.round(canvas.width / settings.outputSize);
  return { cx, cy, ps, outputSize: settings.outputSize, rect, sx, sy };
}

function updateCursorPreview(event) {
  if (!activeBrush || ctrlHeld || eyedropperActive) { brushCursor.style.display = 'none'; return; }

  const rect = canvasWrap.getBoundingClientRect();
  const canvasRect = browserCanvas.getBoundingClientRect();

  // Canvas position in content space (accounts for scroll offset)
  const canvasOffX = canvasRect.left - rect.left + canvasWrap.scrollLeft;
  const canvasOffY = canvasRect.top - rect.top + canvasWrap.scrollTop;

  const sx = browserCanvas.width / canvasRect.width;
  const sy = browserCanvas.height / canvasRect.height;
  const rawX = (event.clientX - canvasRect.left) * sx;
  const rawY = (event.clientY - canvasRect.top) * sy;

  const settings = getSettings();
  const ps = Math.round(browserCanvas.width / settings.outputSize);
  if (ps < 1) return;

  const gx = Math.floor(rawX / ps);
  const gy = Math.floor(rawY / ps);

  // Convert grid position back to CSS pixels in content space
  const cssLeft = canvasOffX + (gx * ps) / sx;
  const cssTop = canvasOffY + (gy * ps) / sy;
  const cssWidth = (brushSize * ps) / sx;
  const cssHeight = (brushSize * ps) / sy;

  brushCursor.style.display = 'block';
  brushCursor.style.left = cssLeft + 'px';
  brushCursor.style.top = cssTop + 'px';
  brushCursor.style.width = cssWidth + 'px';
  brushCursor.style.height = cssHeight + 'px';

  if (activeBrush.a === 0) {
    brushCursor.classList.add('transparent-brush');
  } else {
    brushCursor.classList.remove('transparent-brush');
    brushCursor.style.borderColor = `rgb(${activeBrush.r},${activeBrush.g},${activeBrush.b})`;
  }
}

browserCanvas.addEventListener('mousemove', updateCursorPreview);
browserCanvas.addEventListener('mouseleave', () => { brushCursor.style.display = 'none'; });


// ============================================================
// Paint â€” click and drag (left click)
// ============================================================

let isPainting = false;
let lastPaintGrid = null;  // {gx, gy} to avoid repainting same cell
let paintUndoPushed = false;

function paintAt(canvas, gx, gy) {
  const settings = getSettings();
  const ps = Math.round(canvas.width / settings.outputSize);
  if (ps < 1) return;

  const ctx = canvas.getContext('2d');
  for (let dy = 0; dy < brushSize; dy++) {
    for (let dx = 0; dx < brushSize; dx++) {
      const tx = gx + dx, ty = gy + dy;
      if (tx >= settings.outputSize || ty >= settings.outputSize || tx < 0 || ty < 0) continue;
      if (activeBrush.a === 0) {
        ctx.clearRect(tx * ps, ty * ps, ps, ps);
      } else {
        ctx.fillStyle = `rgb(${activeBrush.r},${activeBrush.g},${activeBrush.b})`;
        ctx.fillRect(tx * ps, ty * ps, ps, ps);
      }
    }
  }
}

function onPaintStart(event) {
  if (event.button !== 0) return;

  // Ctrl+click = eyedropper
  if (event.ctrlKey || event.metaKey || eyedropperActive) {
    event.preventDefault();
    pickColor(browserCanvas, event);
    return;
  }

  if (!activeBrush) return;
  event.preventDefault();

  const { cx, cy, ps, outputSize } = canvasToPixel(browserCanvas, event);
  if (ps < 1) return;
  const gx = Math.floor(cx / ps);
  const gy = Math.floor(cy / ps);

  // Push undo once at start of stroke
  pushUndo();
  clearRedo();
  paintUndoPushed = true;
  setRetouchDirty(true);
  isPainting = true;
  lastPaintGrid = { gx, gy };

  paintAt(browserCanvas, gx, gy);
}

function onPaintMove(event) {
  // Update cursor preview (skip if in eyedropper mode)
  if (ctrlHeld || eyedropperActive) {
    brushCursor.style.display = 'none';
  } else {
    updateCursorPreview(event);
  }

  if (!isPainting || !activeBrush) return;

  const { cx, cy, ps, outputSize } = canvasToPixel(browserCanvas, event);
  if (ps < 1) return;
  const gx = Math.floor(cx / ps);
  const gy = Math.floor(cy / ps);

  // Skip if same grid cell
  if (lastPaintGrid && lastPaintGrid.gx === gx && lastPaintGrid.gy === gy) return;
  lastPaintGrid = { gx, gy };

  paintAt(browserCanvas, gx, gy);
}

function onPaintEnd() {
  isPainting = false;
  lastPaintGrid = null;
  paintUndoPushed = false;
}

browserCanvas.addEventListener('mousedown', onPaintStart);
browserCanvas.addEventListener('mousemove', onPaintMove);
document.addEventListener('mouseup', onPaintEnd);

// ============================================================
// Flood fill (right click)
// ============================================================

function floodFill(canvas, event) {
  if (!activeBrush) return;
  event.preventDefault();

  const { cx, cy, ps, outputSize } = canvasToPixel(canvas, event);
  if (ps < 1) return;
  const gx = Math.floor(cx / ps);
  const gy = Math.floor(cy / ps);
  if (gx < 0 || gx >= outputSize || gy < 0 || gy >= outputSize) return;

  pushUndo();
  clearRedo();
  setRetouchDirty(true);

  const ctx = canvas.getContext('2d');
  const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const d = imgData.data;

  // Read the target color at the clicked pixel (sample center of the block)
  const si = ((gy * ps + Math.floor(ps / 2)) * canvas.width + (gx * ps + Math.floor(ps / 2))) * 4;
  const tr = d[si], tg = d[si + 1], tb = d[si + 2], ta = d[si + 3];

  // Don't fill if target matches brush
  if (activeBrush.a === 0 && ta === 0) return;
  if (activeBrush.a !== 0 && tr === activeBrush.r && tg === activeBrush.g && tb === activeBrush.b && ta === 255) return;

  const visited = new Uint8Array(outputSize * outputSize);
  const queue = [gy * outputSize + gx];
  visited[queue[0]] = 1;

  function matchTarget(px, py) {
    const idx = ((py * ps + Math.floor(ps / 2)) * canvas.width + (px * ps + Math.floor(ps / 2))) * 4;
    return d[idx] === tr && d[idx + 1] === tg && d[idx + 2] === tb && d[idx + 3] === ta;
  }

  let qi = 0;
  while (qi < queue.length) {
    const idx = queue[qi++];
    const px = idx % outputSize, py = (idx - px) / outputSize;
    // Paint this pixel block
    for (let by = 0; by < ps; by++) {
      for (let bx = 0; bx < ps; bx++) {
        const fi = ((py * ps + by) * canvas.width + (px * ps + bx)) * 4;
        if (activeBrush.a === 0) {
          d[fi] = 0; d[fi + 1] = 0; d[fi + 2] = 0; d[fi + 3] = 0;
        } else {
          d[fi] = activeBrush.r; d[fi + 1] = activeBrush.g; d[fi + 2] = activeBrush.b; d[fi + 3] = 255;
        }
      }
    }
    // Spread to neighbors
    const neighbors = [];
    if (px > 0) neighbors.push(idx - 1);
    if (px < outputSize - 1) neighbors.push(idx + 1);
    if (py > 0) neighbors.push(idx - outputSize);
    if (py < outputSize - 1) neighbors.push(idx + outputSize);
    for (const ni of neighbors) {
      if (visited[ni]) continue;
      visited[ni] = 1;
      const nx = ni % outputSize, ny = (ni - nx) / outputSize;
      if (matchTarget(nx, ny)) queue.push(ni);
    }
  }

  ctx.putImageData(imgData, 0, 0);
}

browserCanvas.addEventListener('contextmenu', (e) => floodFill(browserCanvas, e));


// ============================================================
// Eyedropper Tool
// ============================================================

let eyedropperActive = false;
let ctrlHeld = false;
let savedBrushSize = null;  // stash brush size while Ctrl held

function setEyedropperActive(active) {
  eyedropperActive = active;
  btnEyedropper.classList.toggle('active', active);
  browserCanvas.classList.toggle('eyedropper-active', active || ctrlHeld);
  if (active || ctrlHeld) {
    brushCursor.style.display = 'none';
  }
}

btnEyedropper.addEventListener('click', () => {
  setEyedropperActive(!eyedropperActive);
});

function pickColor(canvas, event) {
  const { cx, cy, ps, outputSize } = canvasToPixel(canvas, event);
  if (ps < 1) return;
  const gx = Math.floor(cx / ps);
  const gy = Math.floor(cy / ps);
  if (gx < 0 || gx >= outputSize || gy < 0 || gy >= outputSize) return;

  const ctx = canvas.getContext('2d');
  // Sample center of the pixel block
  const sampleX = gx * ps + Math.floor(ps / 2);
  const sampleY = gy * ps + Math.floor(ps / 2);
  const pixel = ctx.getImageData(sampleX, sampleY, 1, 1).data;

  const color = pixel[3] === 0
    ? { r: 0, g: 0, b: 0, a: 0 }
    : { r: pixel[0], g: pixel[1], b: pixel[2], a: 255 };

  // Find matching swatch and select it, or create a virtual selection
  const swatches = document.querySelectorAll('#browserSwatches .swatch');
  let matched = false;
  for (const s of swatches) {
    const bg = s.style.background;
    if (color.a === 0 && s.classList.contains('transparent')) {
      selectBrush(s, color);
      matched = true;
      break;
    }
    if (color.a !== 0 && bg === `rgb(${color.r}, ${color.g}, ${color.b})`) {
      selectBrush(s, color);
      matched = true;
      break;
    }
  }
  if (!matched) {
    // Color not in palette â€” set brush directly without a swatch
    clearBrush();
    activeBrush = color;
    browserCanvas.classList.add('brush-active');
    updateBrushPreview();
  }

  // Turn off eyedropper tool after picking (unless Ctrl is still held)
  if (!ctrlHeld) {
    setEyedropperActive(false);
  }
}


// ============================================================
// Embed Mode (iframe integration with parent app)
// ============================================================

const embedParams = new URLSearchParams(window.location.search);
const isEmbedMode = embedParams.get('mode') === 'embed';

if (isEmbedMode) {
  document.body.classList.add('embed-mode');

  // Apply SNES-appropriate presets
  document.getElementById('outputSize').value = '64';
  document.getElementById('paletteColors').value = '16';
  document.getElementById('snesSnap').checked = true;
  document.getElementById('removeBg').checked = true;
  document.getElementById('dither').value = 'bayer2x2';
  document.getElementById('scale').value = '8';

  // Lock palette if specified
  const embedPalette = embedParams.get('palette');
  if (embedPalette) {
    document.getElementById('paletteName').value = embedPalette;
  }

  // Save Portrait button
  document.getElementById('btnSavePortrait').addEventListener('click', () => {
    if (!browserResult) return;

    // Extract the raw 64x64 pixel art (not the upscaled display canvas)
    const outputSize = parseInt(document.getElementById('outputSize').value);
    const rawCanvas = document.createElement('canvas');
    rawCanvas.width = outputSize;
    rawCanvas.height = outputSize;
    const rawCtx = rawCanvas.getContext('2d');
    rawCtx.imageSmoothingEnabled = false;
    rawCtx.drawImage(browserCanvas, 0, 0, outputSize, outputSize);

    const dataUrl = rawCanvas.toDataURL('image/png');
    window.parent.postMessage({
      type: 'portrait-complete',
      data: dataUrl,
    }, '*');
  });

  // Cancel button
  document.getElementById('btnCancelEmbed').addEventListener('click', () => {
    window.parent.postMessage({ type: 'portrait-cancel' }, '*');
  });

  // Enable Save button when portrait is generated (hook into existing pipeline)
  const _origOnPipelineSuccess = () => {
    document.getElementById('btnSavePortrait').disabled = false;
  };
  // Observe the browserDot class change to detect pipeline completion
  const observer = new MutationObserver(() => {
    if (browserDot.classList.contains('active')) {
      document.getElementById('btnSavePortrait').disabled = false;
    }
  });
  observer.observe(browserDot, { attributes: true, attributeFilter: ['class'] });

  // Listen for init messages from parent
  window.addEventListener('message', (e) => {
    if (e.data && e.data.type === 'portrait-init') {
      // Parent can send context (e.g., contact name for title)
      if (e.data.contactName) {
        document.title = `Portrait: ${e.data.contactName}`;
      }
    }
  });
}


// ============================================================
// Keyboard shortcuts + Ctrl modifier for eyedropper
// ============================================================

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    clearBrush();
    setEyedropperActive(false);
  }
  if (e.key >= '1' && e.key <= '4' && activeBrush && !ctrlHeld) {
    setBrushSize(parseInt(e.key));
  }
  if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === 'z') {
    e.preventDefault();
    popRedo();
    return;
  }
  if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
    e.preventDefault();
    popUndo();
    return;
  }
  // Ctrl hold â†’ temporary eyedropper mode
  if ((e.key === 'Control' || e.key === 'Meta') && !ctrlHeld) {
    ctrlHeld = true;
    savedBrushSize = brushSize;
    browserCanvas.classList.add('eyedropper-active');
    brushCursor.style.display = 'none';
  }
});

document.addEventListener('keyup', (e) => {
  if ((e.key === 'Control' || e.key === 'Meta') && ctrlHeld) {
    ctrlHeld = false;
    browserCanvas.classList.remove('eyedropper-active');
    if (!eyedropperActive) {
      // Restore brush cursor behavior
      if (savedBrushSize !== null) {
        setBrushSize(savedBrushSize);
        savedBrushSize = null;
      }
    }
  }
});


// ============================================================
// File Organizer: Filename Construction
// ============================================================

const PALETTE_ABBREV = {
  '':               'Auto',
  'chrono-trigger':  'CT',
  'ff6-portraits':   'FF6',
  'jehkoba32':       'Jk32',
  'snes-warm':       'SNW',
  'snes-cool':       'SNC',
};

const DITHER_ABBREV = {
  'none':            'ND',
  'bayer2x2':        'B2',
  'bayer4x4':        'B4',
  'floyd-steinberg': 'FS',
};

function buildFilename() {
  const root = (document.getElementById('foRootName').value.trim() || 'portrait')
    .replace(/[\/\\:*?"<>|]/g, '_');
  const settings = getSettings();
  const parts = [root];

  if (document.getElementById('foIncSize').checked) {
    parts.push(String(settings.outputSize));
  }
  if (document.getElementById('foIncColors').checked) {
    parts.push(settings.paletteColors + 'c');
  }
  if (document.getElementById('foIncPalette').checked) {
    const abbrev = PALETTE_ABBREV[settings.paletteName];
    parts.push(abbrev !== undefined ? abbrev : settings.paletteName);
  }
  if (document.getElementById('foIncDither').checked) {
    parts.push(DITHER_ABBREV[settings.dither] || settings.dither);
  }
  if (document.getElementById('foIncSnes').checked && settings.snesSnap) {
    parts.push('SNES');
  }
  if (document.getElementById('foIncRemoveBg').checked && settings.removeBg) {
    const thresh = Math.round(settings.bgThreshold * 100);
    parts.push('NoBG' + thresh);
  }
  if (document.getElementById('foIncScale').checked) {
    parts.push(settings.scale + 'x');
  }
  if (document.getElementById('foIncRetouched').checked && retouchDirty) {
    parts.push('RTd');
  }

  return parts.join('_') + '.png';
}

function updateFilenamePreview() {
  const filename = buildFilename();
  const previewEl = document.getElementById('foFilenamePreview');
  const root = (document.getElementById('foRootName').value.trim() || 'portrait')
    .replace(/[\/\\:*?"<>|]/g, '_');
  const suffix = filename.slice(root.length);
  previewEl.innerHTML = `<span>${root}</span><span class="fo-dim">${suffix}</span>`;
}


// ============================================================
// File Organizer: File System Access API + Save
// ============================================================

let directoryHandle = null;
const hasDirectoryPicker = typeof window.showDirectoryPicker === 'function';

const foPanel      = document.getElementById('fileOrganizer');
const foToggle     = document.getElementById('foToggle');
const foBrowse     = document.getElementById('foBrowse');
const foDirectory  = document.getElementById('foDirectory');
const foRootName   = document.getElementById('foRootName');
const foSave       = document.getElementById('foSave');

// Collapse/expand toggles for both right-rail panels
foToggle.addEventListener('click', () => {
  foPanel.classList.toggle('collapsed');
});

const rpPanel = document.getElementById('retouchPanel');
const rpToggle = document.getElementById('rpToggle');
rpToggle.addEventListener('click', () => {
  rpPanel.classList.toggle('collapsed');
});

// Directory picker
if (!hasDirectoryPicker) {
  foBrowse.disabled = true;
  foBrowse.title = 'Directory picker not supported in this browser â€” files will download normally';
}

foBrowse.addEventListener('click', async () => {
  if (!hasDirectoryPicker) return;
  try {
    directoryHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
    foDirectory.value = directoryHandle.name;
    updateSaveEnabled();
  } catch (err) {
    if (err.name !== 'AbortError') {
      console.error('Directory picker error:', err);
    }
  }
});

// Save button enable/disable
function updateSaveEnabled() {
  foSave.disabled = !browserResult;
  if (hasDirectoryPicker && directoryHandle) {
    foSave.textContent = 'Save PNG';
  } else {
    foSave.textContent = 'Download PNG';
  }
}

// Save action
foSave.addEventListener('click', async () => {
  if (!browserResult) return;

  const filename = buildFilename();

  if (hasDirectoryPicker && directoryHandle) {
    try {
      const fileHandle = await directoryHandle.getFileHandle(filename, { create: true });
      const writable = await fileHandle.createWritable();
      const blob = await new Promise(resolve => {
        browserResult.toBlob(resolve, 'image/png');
      });
      await writable.write(blob);
      await writable.close();

      // Visual feedback
      foSave.textContent = 'Saved!';
      foSave.style.background = 'var(--success)';
      foSave.style.borderColor = 'var(--success)';
      setTimeout(() => {
        foSave.style.background = '';
        foSave.style.borderColor = '';
        updateSaveEnabled();
      }, 1500);
    } catch (err) {
      if (err.name === 'NotAllowedError') {
        console.warn('Directory write permission lost, falling back to download');
        directoryHandle = null;
        foDirectory.value = '';
        fallbackDownload(filename);
      } else {
        console.error('Save error:', err);
        alert('Save failed: ' + err.message);
      }
    }
  } else {
    fallbackDownload(filename);
  }
});

function fallbackDownload(filename) {
  const link = document.createElement('a');
  link.download = filename;
  link.href = browserResult.toDataURL('image/png');
  link.click();
}

// Filename preview: update on any organizer or settings change
const foCheckboxIds = [
  'foIncSize', 'foIncColors', 'foIncPalette', 'foIncDither',
  'foIncSnes', 'foIncRemoveBg', 'foIncScale', 'foIncRetouched'
];

for (const id of foCheckboxIds) {
  document.getElementById(id).addEventListener('change', updateFilenamePreview);
}

foRootName.addEventListener('input', updateFilenamePreview);

// Also update preview when main settings change
for (const id of ['outputSize', 'paletteColors', 'paletteName', 'dither',
                   'snesSnap', 'removeBg', 'bgThreshold', 'scale']) {
  const el = document.getElementById(id);
  el.addEventListener('change', updateFilenamePreview);
  el.addEventListener('input', updateFilenamePreview);
}

</script>
</body>
</html>
